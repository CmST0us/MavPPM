
# 1. TODO

- [ ] replace: Usbmuxd -> usbmuxd
- [ ] replace: mavlink -> MAVLink

-----------------------

# 2. 基于移动端重力感应的无人机遥控系统

# 3. 摘要
1. 移动互联网发展，无人机普及
2. 在无人机爱好者中，有非常多的人喜欢自己组装一台无人机。
3. 本系统提出了一种可以使用移动设备（以iOS为例）的重力感应控制无人机的方法。通过此系统，使用者可以使用手机（以搭载iOS系统的设备为例）控制无人机。虽然本设计目的是使用重力感应控制无人机，但是在设计时，考虑到扩展和兼容性。使用者只需要更通过更新软件的方式，就可以实现更多的操控方式，例如使用外置手柄或者虚拟摇杆。大大降低无人机在控制上的成本。
4. 
# 4. Abs...

# 5. 目录
<!-- TOC -->

- [1. TODO](#1-todo)
- [2. 基于移动端重力感应的无人机遥控系统](#2-基于移动端重力感应的无人机遥控系统)
- [3. 摘要](#3-摘要)
- [4. Abs...](#4-abs)
- [5. 目录](#5-目录)
    - [5.1. 术语说明](#51-术语说明)
- [6. 前言](#6-前言)
    - [6.1. 设计意义](#61-设计意义)
    - [6.2. 设计依据](#62-设计依据)
        - [6.2.1. TCP通信](#621-tcp通信)
        - [6.2.2. usbmuxd通信](#622-usbmuxd通信)
            - [6.2.2.1. usbmuxd协议](#6221-usbmuxd协议)
            - [6.2.2.2. 设备监听请求](#6222-设备监听请求)
            - [6.2.2.3. 设备连接请求](#6223-设备连接请求)
        - [6.2.3. mavlink协议](#623-mavlink协议)
        - [6.2.4. PPM协议](#624-ppm协议)
        - [6.2.5. iOS系统](#625-ios系统)
        - [6.2.6. Linux系统](#626-linux系统)
    - [6.3. 设计内容](#63-设计内容)
        - [6.3.1. 移动设备](#631-移动设备)
        - [6.3.2. 外设](#632-外设)
        - [6.3.3. 高频头](#633-高频头)
    - [6.4. 文献综述](#64-文献综述)
- [7. 总体方案确定](#7-总体方案确定)
    - [7.1. 方案比较](#71-方案比较)
    - [7.2. 方案选择](#72-方案选择)
        - [7.2.1. 通信方案](#721-通信方案)
        - [7.2.2. 硬件方案](#722-硬件方案)
        - [7.2.3. 软件方案](#723-软件方案)
- [8. 理论分析及设计](#8-理论分析及设计)
    - [8.1. 理论计算与分析](#81-理论计算与分析)
        - [8.1.1. 重力感应控制原理](#811-重力感应控制原理)
    - [8.2. 系统、配件、程序设计](#82-系统配件程序设计)
        - [8.2.1. 系统数据流设计](#821-系统数据流设计)
        - [8.2.2. 通信层代码设计](#822-通信层代码设计)
            - [8.2.2.1. 通信接口](#8221-通信接口)
            - [8.2.2.2. 事件回调](#8222-事件回调)
            - [8.2.2.3. 运行循环](#8223-运行循环)
            - [8.2.2.4. 线程安全](#8224-线程安全)
        - [8.2.3. 重力感应控制层代码设计](#823-重力感应控制层代码设计)
            - [8.2.3.1. 接口设计](#8231-接口设计)
            - [8.2.3.2. 多数据获取](#8232-多数据获取)
        - [8.2.4. APP设计](#824-app设计)
            - [8.2.4.1. 链路管理模块](#8241-链路管理模块)
            - [8.2.4.2. mavlink数据包监听分发模块](#8242-mavlink数据包监听分发模块)
            - [8.2.4.3. 通道绑定模块](#8243-通道绑定模块)
            - [8.2.4.4. 控制反馈模块](#8244-控制反馈模块)
            - [8.2.4.5. 姿态指示控件](#8245-姿态指示控件)
        - [8.2.5. 外设控制程序设计](#825-外设控制程序设计)
            - [8.2.5.1. mavlink数据包监听分发模块](#8251-mavlink数据包监听分发模块)
            - [8.2.5.2. 持久化储存模块](#8252-持久化储存模块)
            - [8.2.5.3. PPM信号转换接口设计](#8253-ppm信号转换接口设计)
            - [8.2.5.4. 链路管理模块](#8254-链路管理模块)
        - [8.2.6. 硬件设计](#826-硬件设计)
        - [8.2.7. 仿真系统设计](#827-仿真系统设计)
            - [8.2.7.1. PX4 仿真系统接入](#8271-px4-仿真系统接入)
    - [8.3. 外设元器件选择](#83-外设元器件选择)
- [9. 测试与实验分析](#9-测试与实验分析)
    - [9.1. 测试、调试结果与分析](#91-测试调试结果与分析)
    - [9.2. 模型制作、加工](#92-模型制作加工)
    - [9.3. 实验、仿真结果与分析](#93-实验仿真结果与分析)
- [10. 总结](#10-总结)
- [11. 参考文献](#11-参考文献)
- [12. 附录](#12-附录)
- [13. 致谢](#13-致谢)

<!-- /TOC -->

## 5.1. 术语说明
1. 本系统中提到的移动设备、手机等特指搭载iOS系统的iPhone，iPad等设备。
2. 本系统中提到的Cube、外设、嵌入式设备特指本系统中负责mavlink协议接受转换的嵌入式系统。
3. 本系统中提到的开发机，特指开发本系统软件搭载Apple macOS 系统电脑。

# 6. 前言

## 6.1. 设计意义
此系统除了实现使用移动设备重力感应控制无人机的功能外，另一方面提供了一种思路，即如何让移动设备在本身硬件不支持某种无线通信方式时，和目标进行数据通信。

在本系统中，控制目标接收经过调制后的PPM信号，而移动设备本身并不能调制发送这种类型的信号。经过此系统调制后，目标就可以正确接收控制信号了。
## 6.2. 设计依据

### 6.2.1. TCP通信
TCP协议，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。[^reference_tcp]

### 6.2.2. usbmuxd通信

usbmuxd是一个可以在USB链路上复用连接的系统，它可以提供一个类似TCP通信的模型，用于处理主机设备与移动设备特定端口间的通信。[^reference_usbmuxd]此通信方式可以将TCP数据包转发至USB，与iOS设备通信。即可以实现使用数据线与iOS设备指定端口通信的能力。

usbmuxd通过IPC，即进程间通信的方式与请求者进行数据交换，在Unix体系系统中，通过创建unix套接字提供服务。请求方可以向usbmuxd服务发送两种命令，一是设备监听枚举，二是目标连接。一旦usbmuxd与请求方握手成功并进入一种命令模式，请求方必须向usbmuxd服务创建一个新的连接才能发送另一个命令。usbmuxd服务在监听模式下，会向请求方回调当前插入的设备与拔出的设备。在目标连接模式下，请求方向usbmuxd服务发送连接请求，一旦连接建立，请求方向usbmuxd发送的所有数据都会转发到目标iOS设备的指定端口。

在usbmuxd通信模型中，类比TCP通信方式，请求方作为客户端的角色，而目标设备作为服务器的角色。故在实现此通信方式时，我们需要在移动设备上运行一个TCP服务器。

#### 6.2.2.1. usbmuxd协议
usbmuxd协议包由两部分组成：包头与负载。其中包头为二进制格式，负载为xml格式的字符串。
usbmuxd包头由4部分组成，以网络字节序编码:

**UsbmuxdHeader**

字段|长度|备注
----|----|----
长度|4字节|包括包头长度
版本|4字节|0为二进制版本，1为plist版本
消息类型|4字节|参见UsbmuxdMessageType，当版本为1时，消息类型需为plist消息

**UsbmuxdMessageType**

字段|值
----|---
请求结果|1
连接请求|2
设备监听请求|3
设备接入|4
设备拔出|5
plist消息|8

由于Apple在最新的系统更新中移除了对二进制usbmuxd协议的支持，所以我们只能使用plist格式的负载小usbmuxd服务传递参数。

负载使用的plist格式类似于xml，是Apple的属性列表，可用于序列化储存数字、布尔、字符串、字典、数组等。【reference plist】

一个plist格式的请求也需要带有usbmuxdHeader包头，其中包头版本为1，消息类型为8. 负载必须包含以下键值对。

键|值类型|备注
--|------|----
MessageType|字符串|消息类型

其中消息类型支持以下几种：

字段|备注
---|---
Listen|设备监听请求
Connect|连接请求
Result|请求结果
Attach|设备接入
Detached|设备拔出

包含请求结果的数据包也由usbmuxdHeader包头与负载组成，其中包头版本为1，消息类型为8.负载包含的键值对满足一下格式：

键|值类型|备注
--|------|----
MessageType|字符串|值为Result
Number|整数|请求结果

其中返回结果一般有一下几种：

字段|备注
---|---
0|请求成功
1|请求错误
2|设备错误
3|连接拒接
5|请求包长度错误
6|版本错误



#### 6.2.2.2. 设备监听请求

请求方可以usbmuxd服务请求监听设备插拔状态。请求包负载中MessageType的值为Listen。usbmuxd收到监听请求包后返回包含请求结果的usbmuxd包头与负载。

当请求方成功请求设备监听服务时，每当usbmuxd服务监测到有设备接入，就会向请求方发送包含接入设备基本信息的数据包。此数据包也由包头与负载组成。负载包含的键值对如下表所示：

键|值类型|备注
--|------|----
DeviceID|整数|表示连接设备的ID
Properties|字典|连接设备的设备信息

Properties字典包含一下键值对：

键|值类型|备注
--|------|----
ProductID|整数|设备产品ID
SerialNumber|字符串|设备序列号
LocationID|整数|设备位置ID

如果后续逻辑中，需要连接到接入的设备，我们只需要关注DeviceID即可。

同理，当设备被拔出后，usbmuxd服务也会向请求方发送一个包含拔出设备DeviceID的数据包，请求方根据此DeviceID释放对应资源即可。

为了保证DeviceID不重复，usbmuxd服务在其生命周期内保证了DeviceID只增不减。

#### 6.2.2.3. 设备连接请求

请求方可以向usbmuxd发送连接请求，以连接到目标设备的指定端口。连接请求除了需要设置请求负载MessageType值为Connect外，还应包含几个额外参数。

键|值类型|备注
--|------|----
DeviceID|整数|连接设备ID
PortNumber|整数|连接设备端口(网络字节序)

DeviceID为接入的设备的ID，PortNumber为需要连接到的端口号。其中PortNumber应为网络字节序，即最高有效位在前。

一旦连接请求返回成功，后续请求方向usbmuxd服务发送的所有数据都会被转发到目标设备中。

### 6.2.3. mavlink协议
MAVLink(Micro Air Vehicle Link)通信协议最早是由苏黎世联邦理工学园计算机视觉与几何实验组的Lorenz Meier在2009年发布的一款轻量级的开源通信协议，它遵守LGPL(Lesser General Public License)开源协议。MAVLink通信协议是在串口通信的基础上一种更高层的开源通信协议，他是微型飞行器与地面站之间通讯，以及与微型飞行器之间常用的通讯协议。目前该协议已经在APM、PX4、、PIXHAWK等飞控平台进行了大量的测试，并且很好得应用在各大飞控平台。[^reference_mavlink]
MAVLink协议同时兼顾了速度与安全性，一帧有限MAVLink数据包最小为8字节，最大为263字节。下图为MAVLink帧格式：
【MAVLink协议帧】

字段|长度（字节）|值域|作用
---|----------|----|---
STX|1|0xFE(1.0版本)，0x55(0.9版本)|表示帧开始
LEN|1|[0,255]|负载长度
SEQ|1|[0,255]|用于计算信道质量
SYS|1|[1,255]|表示发送此帧设备系统标号
COMP|1|[0,255]|表示发送此帧设备单元编号
MSG|1|[0,255]|负载消息类型编号
PAYLOAD|n|n字节，n < 255|负载数据
CRC|2|Difference|16位CRC校验部分

帧头部分使用0xFE和0x55作为帧开始标志，同时标示此MAVLink帧版本，在本系统中，使用1.0版本的MAVLink协议，即帧开始标志为0xFE。
在MAVLink消息中，通过MSG字段区分PAYLOAD中的不同的消息类型。

在本系统中，主要使用消息ID位0的心跳包与消息ID为【手动控制消息ID】手动控制包。


心跳包负载格式如下表所示：

字段|长度（字节）|值域|作用
---|----------|----|---
type|1|[0,255]|飞行器型号
autopilot|1|[0,255]|飞控型号
base_mode|1|[0,255]|当前基础模式
custom_mode|4|4 bytes|当前用户定义模式
system_status|1|[0,255]|系统状态
mavlink_version|1|uint8_mavlink_version|MAVLink消息版本

【TODO】
手动控制负载格式如下表所示：

字段|长度（字节）|值域|作用
---|----------|----|---

### 6.2.4. PPM协议
【reference PPM， wiki， 知网】
### 6.2.5. iOS系统
【reference iOS， wiki，the iPhone wiki， developer.apple.com】
### 6.2.6. Linux系统
【reference wiki， 】
## 6.3. 设计内容
系统总体架构图如下图所示
【架构图】
从硬件上，系统一共分为三部分：移动设备，外设，高频头。
### 6.3.1. 移动设备
移动设备是本系统中直接与使用者交互的部分，使用者可以通过移动设备的重力感应来控制无人机。为了实现对应功能，在软件上，将此部分分为三层
1. UI层：用于展示操作控件，信息，处理使用者与移动设备交互动作。
2. 通信层：用于与外设使用特定的协议进行数据通信。
3. 重力感应控制层：封装iOS 重力感应控制API，使其更加适合本系统，有效得统一管理。
### 6.3.2. 外设
外设负责处理移动设备发送的控制协议，将mavlink控制协议处理后，转换为高频头的PPM输入信号。软件部分分为3层：
1. 核心逻辑层：此层用于处理各种转换逻辑，同时也是外设程序入口。
2. 通信层：用于与移动设备使用特定的协议进行数据通信。
3. PPM信号转换层：调用外设板级资源，将mavlink控制信号转换为PPM控制信号。
### 6.3.3. 高频头
由于无人机接收机接收到有效的控制信号为进过调制后的PPM信号，因此需要一个硬件做这样的信号调制。此组件唯一的功能就是PPM信号调制。

## 6.4. 文献综述
【TODO】


# 7. 总体方案确定

## 7.1. 方案比较

经过前期调研，基本确定了两种实现方案。
1. 使用移动设备+外设+高频头
2. 使用移动设备+外设+PPM调制芯片+高频头

两者最大的差别在与PPM调制方式上，方案一使用外设嵌入式板级GPIO资源，通过软件模拟的方式让GPIO口发送PPM信号。
而方案二加入了一块PPM调制芯片，使用串口向调制芯片发送PPM信号各通道数据，让PPM调制芯片专门负责PPM信号调制。


## 7.2. 方案选择

### 7.2.1. 通信方案

iOS设备与外部设备通信方式非常有限：
1. MFi
2. BLE 蓝牙
3. WiFi
4. 蜂窝数据
5. usbmuxd

MFi作为Apple官方认证的通信方式，允许iOS设备与外设【reference Apple MFi guide】。但是此方案需要在企业层面与Apple合作，在外设中加入加密芯片，开发成本过高。不适合此系统的设计规模。
BLE、WiFi、和蜂窝数据都是无线通信方式，在考虑信道带宽的同时也要考虑稳定性，由于本系统需要较高的可靠性和鲁棒性，故不选择。
usbmuxd通信方式【reference wiki】，满足本系统对成本和可靠性的需求。

### 7.2.2. 硬件方案

对于硬件上的两个方案，更多的从软件成本上做了选择。方案一虽然可以减少硬件成本，和方案二相比少了一颗调制IC与其外围元件的价格，但是从软件开发成本上考虑就高了很多。首先外设的软件运行在嵌入式Linux系统上，而嵌入式Linux系统的实时性不高，系统需要使用更多的时间做线程上下文切换，分配给每个线程的时间片也不同。这就会导致GPIO口输出反转的时序不精确。在直接使用bash和文件操作的方法循环翻转一个GPIO口的输出，使用逻辑分析仪测得翻转延时最低为5ms，而PPM信号低电平触发时间为0.3ms，这远远不能满足时序要求。
其次如果直接操作CPU寄存器控制IO口，虽然测的翻转延时可以到0.001ms，但是由于系统级别的线程或者进程管理，导致不能精确延时。实际测得1.2ms高电平延时，实际可能会超时到2ms甚至更长。这也是不能满足PPM信号要求的。
对比其他嵌入式实时操作系统，Linux在GPIO信号控制的表现实在不能满足系统的需求。如果想让Linux提供一个实时环境，我们可以通过编写内核驱动，调用系统中断的方式实现，或者使用Xenomai的大小核方式，为Linux提供一个实时内核环境。但是不论哪种方式，对系统整体来说，提高了软件开发成本与学习成本。
最后决定使用加一颗串口转PPM的芯片用于输出PPM信号，加上外围原价，硬件成本只增加了9元。

### 7.2.3. 软件方案

本系统涉及2门编程语言（C++，Objective-C），3个操作系统平台(Linux, macOS, 嵌入式Linux)，为了最大限度地重用代码，同时降低各模块之间的耦合。
我们将通信层作为移动设备和外设的通用组件，使其一套代码可以跨平台运行。故使用C++ 11作为编写语言，使用CMake作为构建系统。其次，由于外设运行在嵌入式Linux系统中，因其运算性能限制，不能直接在这个系统上编写调试程序。为了解决这个问题，设计了两种软件调试方法。

1. 使用交叉编译工具连，在目标系统，即外设的嵌入式Linux中运行gdb进行远程调试，观察堆栈即输出。
2. 由于目标嵌入式系统为Linux，而开发平台为Apple公司的macOS系统，这两个操作系统虽然内核不同，但本质上都是UNIX-like系统，系统的输入输出接口都符合POSIX风格。其次在外设代码并没有非常多的平台相关代码。所以我们在设计外设软件的时候，只需要为平台相关代码设计一个统一接口，让不同平台实现这个接口，就可以直接在开发机上调试外设程序了。

这两种调试方法有不同的使用场景，方案一主要在开发机上单元测试通过，部署到外设后进行。而方案二是为了提高开发效率设计的，主要为了检查软件逻辑错误。

为了兼顾跨平台构建的需求，我们在系统开发中使用了CMake，但是如何设计构建逻辑也是我们需要考虑的一个问题。对于移动设备软件的开发我们使用Xcode作为编译构建工具，而CMake同时可以生成Xcode工程项目，所以我们可以将部分跨平台组件生成为Xcode工程，在主工程中引入，Xcode编译时就可以自动寻找相关源文件，编译链接了。
但是对于外设的程序，我们就不能使用Xcode作为构建工具了。在方案设计的时候，我们把外设的程序分为了三层，为了这三层互相解耦，我们需要把通信层和PPM信号转换层编译为静态链接库，同时向核心层暴露接口。在这样的设计下，每层都可以有自己的单元测试，需要测试特定功能模块时，就不需要编译整个外设软件了。

在明确构建系统需要面对的问题和构建需求后，我们就能很好得设计出下图所示的工程目录结构与构建逻辑了
【工程目录】
【构建逻辑】

为了方便编译调试，我们为需要跨平台调试的组件编写交叉编译和非交叉编译两套构建脚本。脚本逻辑如下图所示
【构建脚本逻辑】


# 8. 理论分析及设计

## 8.1. 理论计算与分析
### 8.1.1. 重力感应控制原理
【TODO】

## 8.2. 系统、配件、程序设计

### 8.2.1. 系统数据流设计
从移动设备发送到无人机的控制数据包依次经过移动设备、外设、高频头。控制数据包在移动设备和目标无人机之间单向传输。在移动设备和外设间，数据包使用MAVLink协议流式传输。在外设和高频头间，仅传输控制数据包，且控制数据包经过外设PPM编码模块后发送给高频头调制为目标无人机接收机可能接收的无线信号。下图表示了系统数据流：
【系统数据流图】

### 8.2.2. 通信层代码设计
通信层代码负责移动设备与外设、移动设备与仿真平台之间的通信。在本系统中，移动设备与外设是两个独立运行的平台，两个平台间的通信为异步过程，在设计通信层代码时我们需要考虑异步系统的状态同步问题。进一步反映到软件上说，即需要考虑多线程状态同步问题。
在多线程环境中，各线程使用通信模块是必须对通信模块加锁，否则会因为时序问题导致资源竞争，程序出错。一点典型的例子就是在线程A中关闭了通信链路，而这时线程B刚好准备向链路发送数据，此时程序最终表现就会变为不可预知。为了解决这个问题我们需要有一个模块可以顺序处理操作，同时在添加删除操作时也需要保证线程安全。
由于在多线程环境中，每一个线程在处理任务时，其他线程的运行状况都是不可预知的，会存在线程A需要读取数据，而此时线程B正好正在读取数据的情况。故我们还需要设计一个完备的状态机，用于表示一个通信过程状态。
最后，在项目层面，为了提高通信层的可扩展性，便于日后加入更多的协议支持，或移植到其他项目，我们需要设计一套完备的接口。上层调用接口时可以充分利用到编程语言面向对象的多态的特性，让上层协议与具体通信模块解耦。

#### 8.2.2.1. 通信接口
【TODO】
#### 8.2.2.2. 事件回调
【TODO】
#### 8.2.2.3. 运行循环
【TODO】
#### 8.2.2.4. 线程安全
【TODO】

### 8.2.3. 重力感应控制层代码设计
在iOS中，重力感应控制主要通过Core Motion框架提供。使用者通过创建CMMotionManager对象，设置更新周期与回调函数来获取当前设备的姿态信息。在Apple的设计中，CMMotionManager对象在APP生命周期中只能存在一个。我们需要一个单例用于储存这个CMMotionManager。其次，我们需要为Core Motion 框架封装一套接口，为APP提供多种数据融合的回调方式。同时，姿态信息与最终发送给外设的控制信号量之间需要转换，我们还需要一个模块可以线性、或是非线性得将姿态信息转换为控制信号量。与用户的交互，姿态展示时也需要这个模块做姿态信息与空间坐标的转换。
#### 8.2.3.1. 接口设计
【TODO】
#### 8.2.3.2. 多数据获取
【TODO】

### 8.2.4. APP设计
APP作为直接与使用者交互的部分，应充分保证使用体验。对于基本的重力感应控制功能，应有姿态显示，控制反馈等功能。为了更好得兼容各种无人机，APP在配对时应提供通道绑定，通道反向等功能。最后为了保证通信可靠性，与数据包路由，应设计一个模块负责不同类型得MAVLink消息得监听与路由。
#### 8.2.4.1. 链路管理模块
【TODO】
#### 8.2.4.2. mavlink数据包监听分发模块
【TODO】
#### 8.2.4.3. 通道绑定模块
【TODO】
#### 8.2.4.4. 控制反馈模块
【TODO】
#### 8.2.4.5. 姿态指示控件
【TODO】

### 8.2.5. 外设控制程序设计
外设控制程序最主要的功能就是将控制数据包转发到PPM编码芯片，并调制为目标无人机可接收的控制信号。围绕主要功能，程序还应提供用于保存用户配置的模块、分发MAVLink数据包模块与链路管理模块。
#### 8.2.5.1. mavlink数据包监听分发模块
【TODO】
#### 8.2.5.2. 持久化储存模块
【TODO】
#### 8.2.5.3. PPM信号转换接口设计
【TODO】
#### 8.2.5.4. 链路管理模块
【TODO】

### 8.2.6. 硬件设计
为了降低项目复杂度，硬件设计上主要以PCB Layout为主，将选型的电源模块，嵌入式核心板、高频头布局到PCB板上。下图所示为外设电路原理图。
【电路原理图】
下图所示为PCB Layout图
【PCB Layout图】

### 8.2.7. 仿真系统设计
【TODO】
#### 8.2.7.1. PX4 仿真系统接入
【TODO】


## 8.3. 外设元器件选择
外设由三大部分组成
1. 嵌入式Linux核心板
2. 电源模块
3. PPM发射模块

其中嵌入式Linux核心板选择了friendlyarm NanoPi NEO。使用锂电池充放电模块和升压板作为电源模块。使用【Multi？？高频头】和UART转PPM模块作为PPM发射模块，专门处理PPM信号。

friendlyarm NanoPi NEO采用了allwinner H3 SOC，可以运行debian, Ubuntu等多个Linux发行版，便于开发部署软件。
使用了3000mAH的锂电池和【充电板型号】，可以实现4小时续航，并且支持边充边放。


# 9. 测试与实验分析
## 9.1. 测试、调试结果与分析
## 9.2. 模型制作、加工
## 9.3. 实验、仿真结果与分析


# 10. 总结


# 11. 参考文献

[^reference_tcp]: https://zh.wikipedia.org/wiki/传输控制协议
[^reference_usbmuxd]: https://www.theiphonewiki.com/wiki/Usbmux
[^reference_mavlink]: http://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CMFD&dbname=CMFD201901&filename=1018895956.nh&uid=WEEvREdxOWJmbC9oM1NjYkZCbDdrdTViZFpmU2g3cU5GaktBeldYbm1lK24=$R1yZ0H6jyaa0en3RxVUd8df-oHi7XMMDo7mtKT6mSmEvTuk11l2gFA!!&v=MTI1Njg3RGgxVDNxVHJXTTFGckNVUkxPZlpPUm5GeXpoVWJ6TVZGMjZGcnV4RzlqSnFaRWJQSVI4ZVgxTHV4WVM=

# 12. 附录


# 13. 致谢

